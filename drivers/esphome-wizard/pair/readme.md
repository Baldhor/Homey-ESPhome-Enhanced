This file describe the data structure used by the wizard!

General remarks:
- listVirtualDevices initial configuration and listPhysicalDevices are loaded from the main page (when starting the driver), it includes an 'update' processing
- listPhysicalDevices can evolve to include new physical device
- A modification of a physical device (existing) imply the restart of the driver
- listVirtualDevices currentConfiguration is initialized (copy) when entering the related page, and is reset when leaving it (when returning to main page)
  => It must be 'applied' before leaving the page!


listVirtualDevices = [
    {
        id: string Unique identifier of the virtual device as of device.data.id. It is generated by the wizard driver
        initial: {
            name: string Pretty name of the device (no underscrore, ...)
            zoneName: string
            class: string One of CLASS_SUPPORTED (refer to constants.js)
            status: 'unmodified', 'updated' or 'deleted'
            capabilities: [
                {
                    type: string One of CAPABILITY_CONFIGURATION[].type (refer to constants.js)
                    index: number 1 by default, if the same capability type is used several times, the end user can modify the index
                    status: 'unmodified', 'updated' or 'deleted' Initial status depends if the capability is still supported
                    options: {
                        name : string => value : Type depends of the option
                    }
                    physicalDeviceId: string Unique identifier of the physycal device (refer to listPhysicalDevices) 
                    nativeCapabilityId: string Unique identifier of the native capability for the physical device
                }
            ]
        },
        current: {
            name: string (nullable, mandatory) Pretty name of the device (no underscrore, ...)
            zoneName: string
            class: string (nullable, mandatory) One of CLASS_SUPPORTED (refer to constants.js)
            status: 'new', 'unmodified', 'updated', 'modified', 'deleted'
            capabilities: [
                {
                    type: string (nullable, mandatory) One of CAPABILITY_CONFIGURATION[].type (refer to constants.js)
                    index: number (nullable, mandatory) 1 by default, if the same capability type is used several times, the end user can modify the index
                    status: 'new', 'unmodified', 'updated', 'modified' or 'deleted' Calculated status based on initial status and further modification by the end user
                    options: {
                        name : string => value : Type depends of the option
                    }
                    physicalDeviceId: string Unique identifier of the physycal device (refer to listPhysicalDevices) 
                    nativeCapabilityId: string Unique identifier of the native capability for the physical device
                }
            ]
        }
    }
];

Remarks about listVirtualDevices current configuration:
- For new virtual device:
  - name, class are null by default, the end user MUST input a value
- For new capabilities:
  - type is null by default, the end user MUST input a value
  - index is null by default and calculated each time the end user change the type
  - index is a number starting from 1, and is unique for the capability type of the virtual device
  - index can be swapped from one capability to another
  - however, the user can use previosuly used (deleted capability) index (to ensure existing flow are not broken)
  - For exemple, I had index 1 and 2 for capability measure_temperature, I remove both, but I add a new one which must have index 2 to avoid breaking my flows!
    => Index 1 is unused ...
  - If the end user cancel the deletion of a capability, the index are automatically swapped back if needed


listPhysicalDevices = [
    {
        physicalDeviceId: string Unique identifier
        status : 'new', 'available' or 'unavailable'
        used: boolean Indicate if at least one native capability is used
        name: string Pretty name of the physical device, calculated from physical device info
        ipAddress: string
        port: string
        encryptionKey: string
        password: string
        nativeCapabilities : [
            {
                id : string (format: <entityId>:<attribut>)
                entityId : string
                attribut : string
                entityName : string
                type : string
                used : number Indicate how many times this native capability is being used
                value : string Last know value
                configs : {
                    name : string => value : string
                },
                constraints: {
                    name : string => value : string
                },
                specialCase : string (optionnal)
            }
        ]
   }
];

Remarks about listPhysicalDevices:
  - I am not using macAddress as physicalDeviceId, it would make it more difficult to change a physical device (if it get broken)
  - For new physical device:
    - status is 'unused' by default, and become new when at least one native capability is used in a virtual device
  - For existing physical device:
    - status is 'unmodified' by default, it become 'unused' if all its native capability become unused
    - status cannot be modified, as modification are applied immediatly, and the driver configuration is refreshed
