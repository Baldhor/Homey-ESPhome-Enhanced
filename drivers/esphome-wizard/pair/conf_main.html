<!--
    Show a summary of ongoing configuration:
    - Virtual device, its capabilities and related native capabilities => only offer a "goto" button (go to view 'conf_virtual_device')
    - Settings, and its related native capabilities => only offer a "goto" button (go to view 'conf_settings')
    - Unbind native capabilities => only offer a "create a new virtual device" button (then go to view 'conf_virtual_device')

    Initialy, the ongoing configuration is based on current Homey configuration, and the current physical device configuration.
    After each modifications, the ongoing configuration will update.

    This view also has a "confirm" button which will apply definitively all the modifications.
-->
<style>
    table {
        font-family: arial, sans-serif;
        border-collapse: collapse;
        width: 100%;
    }

    td,
    th {
        border: 1px solid #dddddd;
        text-align: left;
        padding: 8px;
    }

    tr:nth-child(even) {
        background-color: #dddddd;
    }
</style>

<script src="front_configuration.js"></script>
<script src="front_utils.js"></script>
<script type="application/javascript">
    Homey.setTitle(Homey.__('wizard.conf_main.title'));
    Homey.setNavigationClose();

    Homey.showLoadingOverlay();
</script>
<label class="homey-form-label" data-i18n="wizard.conf_main.description"></label>

<!--
    physical_device
-->
<br>
<br>
<header class="homey-header">
    <p class="homey-subtitle" data-i18n="wizard.conf_main.physical_device.title">
        <!-- This field will also be translated -->
    </p>
</header>
<div class="homey-form-group">
    <!-- Seems useless, it is built from: <ipAddress> + ':' + <port>
    <div class="homey-form-group">
        <label class="homey-form-label" for="physical_device.id" data-i18n="wizard.conf_main.physical_device.id"></label>
        <input class="homey-form-input" id="physical_device.id" type="text" value="" readonly/>
    </div>
    -->
    <div class="homey-form-group">
        <label class="homey-form-label" for="physical_device.ipAddress"
            data-i18n="wizard.conf_main.physical_device.ipAddress"></label>
        <input class="homey-form-input" id="physical_device.ipAddress" type="text" value="" readonly />
    </div>
    <div class="homey-form-group">
        <label class="homey-form-label" for="physical_device.port"
            data-i18n="wizard.conf_main.physical_device.port"></label>
        <input class="homey-form-input" id="physical_device.port" type="text" value="" readonly />
    </div>
</div>

<!--
    Virtual device list

    Structure expected:
    - Header line
    - Virtual device 'first line', include first native capability
    - Virtual device 'more lines', for other native capability (doesn't repeat the name of the virtual device)
-->
<br>
<br>
<header class="homey-header">
    <p class="homey-subtitle" data-i18n="wizard.conf_main.virtual_devices.title">
        <!-- This field will also be translated -->
    </p>
</header>
<div class="homey-form-group">
    <label id="virtual_devices.none" class="homey-form-label" data-i18n="wizard.conf_main.virtual_devices.none"
        style="color:red;"></label>
    <table id="virtual_devices" style="width:400% !important;">
        <tr>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.virtual_device.name"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.virtual_device.stateLabel"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.homey_capability.name"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.homey_capability.options"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.name"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.attribut"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.virtual_devices.actions.title"></legend>
            </th>
        </tr>
    </table>
    <button id="create_virtual_device" class="homey-button-primary-full"
        data-i18n="wizard.conf_main.virtual_devices.create" onclick="onClickCreateVirtualDevice(event);"></button>
</div>

<!--
    Unbind native capabilities
-->
<br>
<br>
<header class="homey-header">
    <p class="homey-subtitle" data-i18n="wizard.conf_main.unbind_native_capabilities.title">
        <!-- This field will also be translated -->
    </p>
</header>
<div class="homey-form-group">
    <label id="unbind_native_capabilities.info" class="homey-form-label"
        data-i18n="wizard.conf_main.unbind_native_capabilities.info"></label>
    <label id="unbind_native_capabilities.none" class="homey-form-label"
        data-i18n="wizard.conf_main.unbind_native_capabilities.none"></label>
    <table id="unbind_native_capabilities" style="width:400% !important;">
        <tr>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.name"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.type"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.attribut"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.value"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.configs"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.constraints"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.unbind_native_capabilities.action.label">
                </legend>
            </th>
        </tr>
    </table>
</div>
<br>

<!--
    Confirm button
-->
<button id="confirm" class="homey-button-primary-full" data-i18n="wizard.conf_main.confirm"
    onclick="onClickConfirm(event);"></button>


<script type="application/javascript">
    /***************
     * HTML Events *
     ***************/

    function onChangeCapabilityOption(event, virtualDeviceId, nativeCapabilityId, optionId, newValue) {
        console.log('onChangeCapabilityOption:', ...arguments);

        let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
        let capability = virtualDevice.capabilities.filter(capability => capability.nativeCapabilityId === nativeCapabilityId)[0];

        // Value changed ?
        newValue = newValue === '' ? null : newValue;

        // Need to convert new value to the right type?
        console.log('New option value:', newValue, 'of type', typeof newValue);
        switch (optionId) {
            case 'units':
                break;

            case 'decimals':
                newValue = newValue === null ? null : parseInt(newValue);
                break;

            case 'min':
            case 'max':
            case 'step':
                newValue = newValue === null ? null : parseFloat(newValue);
                break;

            case 'zoneActivity':
            case 'approximated':
            case 'getable':
            case 'setable':
                break;

            default:
                return;
        }

        if (capability.options[optionId] !== newValue) {
            Homey.showLoadingOverlay();

            capability.options[optionId] = newValue;

            // Let's store it and refresh the view
            Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                Homey.hideLoadingOverlay();
                Homey.showView('conf_main');
            });
        }
    }

    function onChangeAssignCapability(event, virtualDeviceId, nativeCapabilityId, newValue) {
        console.log('onChangeAssignCapability:', ...arguments);

        // Ignore default choice
        if (newValue !== 'default') {
            Homey.showLoadingOverlay();

            // Get our objects from ongoing configuration
            let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
            let nativeCapability = ongoingConfiguration.nativeCapabilities.filter(nativeCapability => nativeCapability.id === nativeCapabilityId)[0];

            // Let's find the capability of the virtual device
            let capability = virtualDevice.capabilities.filter(capability => capability.nativeCapabilityId === nativeCapabilityId)[0];

            // The value changed?
            if (capability.type !== newValue) {
                // modified?
                if (capability.state === 'unmodified') {
                    // It's an existing capability and it has been modified!
                    capability.state = 'modified';
                }
                capability.type = newValue;

                // We need to initialize the options
                {
                    // Get the capability configuration
                    let capabilityConf = CAPABILITY_CONFIGURATION.filter(compatibleCapability => compatibleCapability.type === capability.type)[0];

                    // We need to initialize the options
                    let options = {};
                    capabilityConf.options.forEach(option => options[option] = null);

                    // Let's check if we can init some values from the native_capability itself
                    Object.keys(options).forEach(key => {
                        switch (key) {
                            case 'units':
                                options[key] = nativeCapability.configs['unit'] ?? null;
                                break;

                            case 'decimals':
                                options[key] = nativeCapability.configs['precision'] ?? null;
                                break;

                            case 'min':
                                options[key] = nativeCapability.constraints['min'] ?? null;
                                break;

                            case 'max':
                                options[key] = nativeCapability.constraints['max'] ?? null;
                                break;

                            case 'step':
                                options[key] = nativeCapability.constraints['step'] ?? null;
                                break;

                            case 'zoneActivity':
                                // no match, default to true
                                options[key] = true;
                                break;

                            case 'approximated':
                                // no match, default to false
                                options[key] = false;
                                break;

                            case 'getable':
                                options[key] = nativeCapability.configs['writeOnly'] ?? null;
                                break;

                            case 'setable':
                                options[key] = nativeCapability.configs['readOnly'] ?? null;
                                break;
                        }
                    });

                    capability.options = options;
                }

                // Let's store it and refresh the view
                Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                    Homey.hideLoadingOverlay();
                    Homey.showView('conf_main');
                });
            } else {
                // Nothing to do
                Homey.hideLoadingOverlay();
            }
        }
    }

    function onChangeAssignNativeCapability(event, virtualDeviceId, nativeCapabilityId) {
        console.log('onChangeAssignNativeCapability:', ...arguments);

        // TODO: Add the ability to assign a capability to a 'new' virtual device (ie. create it!):
        //    - The name of the virtual device could be set to the native capability name
        //    - If only one capability compatible for the native capability, we could also set it directly, meaning init the options too

        if (virtualDeviceId !== 'default') {
            Homey.showLoadingOverlay();

            // Get the virtual device and native capability
            let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
            let nativeCapability = ongoingConfiguration.nativeCapabilities.filter(nativeCapability => nativeCapability.id === nativeCapabilityId)[0];

            // If the virtual device is 'added', then the native capability is just 'added' too
            // If the native capability was previously removed from the same virtual device, we just need to restore it
            // But could be in 'unmodified' or 'modified' state, need to check the initial configuration to make sure
            // Otherwise, it means the native capability is 'added'
            let state = 'added'; // Cover first and last cases
            if (virtualDevice.state !== 'added') {
                let filterVirtualDeviceCapabilities = virtualDevice.capabilities.filter((capability) => capability.nativeCapabilityId === nativeCapabilityId);
                if (filterVirtualDeviceCapabilities.length === 1) {
                    // Found it, it is either 'unmodified' or 'modifie
                    // No need to check if it was previously 'deleted' (let's trust the code ...)
                    virtualDeviceCapability = filterVirtualDeviceCapabilities[0];

                    let initialVirtualDeviceCapability = initial_configuration.virtualDevices.filter((virtualDevice) => virtualDevice.id === virtualDeviceId)[0].capabilities.filter((capability) => capability.nativeCapabilityId === nativeCapabilityId)[0];
                    if (compareVirtualDeviceCapabilityOptions(initialVirtualDeviceCapability.options, virtualDeviceCapability.options)) {
                        // Same
                        state = 'unmodified';
                    } else {
                        state = 'modified';
                    }

                    // Actually, we just need to restore it with the correct state
                    virtualDeviceCapability.state = state;
                    nativeCapability.state = 'bound';

                    // Let's store it and refresh the view
                    Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                        Homey.hideLoadingOverlay();
                        Homey.showView('conf_main');
                    });
                    return;
                }
            }

            let capabilityType = null;

            // TODO: If only one capability compatible for the native capability, we could set it directly, meaning init the options too

            // It's a new capability for the virtual device
            let capability = {
                type: capabilityType,
                'nativeCapabilityId': nativeCapabilityId,
                'state': state,
                options: []
            };
            virtualDevice.capabilities.push(capability);
            nativeCapability.state = 'bound';

            // Let's store it and refresh the view
            Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                Homey.hideLoadingOverlay();
                Homey.showView('conf_main');
            });
        }
    }

    /**
     * This function add a virtual device
     * 
     * By default:
     * - Its name is generated : new1, new2, ...
     * - it doesn't have any native capability, the user need to add at least one
     * 
     * /!\ Name must be changed and at least one native capaibility must be added, otherwise the confirm button is disabled
     */
    function onClickCreateVirtualDevice(event) {
        console.log('onClickCreateVirtualDevice:', ...arguments);

        Homey.showLoadingOverlay();

        // Get nextValue from the store
        Homey.getViewStoreValue('store', 'last_virtual_device_id').then(lastId => {
            if (!lastId) {
                lastId = 0;
            }

            let nextId = lastId + 1;
            Homey.setViewStoreValue('store', 'last_virtual_device_id', nextId).then(() => {
                // finaly, we got an id, let's create a virtual device
                let newVirtualDevice = {
                    id: 'new_' + nextId,
                    homeyId: null,
                    name: 'new_' + nextId,
                    nameMustBeChanged: true,
                    state: 'added',
                    capabilities: []
                };

                // We can add it to the ongoing_configuration
                ongoingConfiguration.virtualDevices.push(newVirtualDevice);

                // Let's store it and refresh the view
                Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                    Homey.hideLoadingOverlay();
                    Homey.showView('conf_main');
                });
            });
        });
    }

    function onChangeVirtualDeviceNameChanged(event, virtualDeviceId, newName) {
        console.log('onChangeVirtualDeviceNameChanged:', ...arguments);

        // Let's check the newName format
        if (/^[A-Za-z0-9][A-Za-z0-9-_ ]{1,28}[A-Za-z0-9]{1,1}$/.test(newName)) {
            Homey.showLoadingOverlay();
            ongoingConfiguration.virtualDevices.forEach(virtualDevice => {
                if (virtualDevice.id === virtualDeviceId) {
                    virtualDevice.name = newName;
                    virtualDevice.nameMustBeChanged = false;
                }
            });

            // Let's store it and refresh the view
            Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                Homey.hideLoadingOverlay();
                Homey.showView('conf_main');
            });
        } else {
            // Not nice, alert and reload
            // TODO: There are must be better way to handle it, but it is simple :)
            Homey.alert(Homey.__('wizard.conf_main.virtual_devices.change_name_format'));
            Homey.showView('conf_main');
        }
    }

    function onClickRestoreVirtualDevice(event) {
        console.log('onClickRestoreVirtualDevice:', ...arguments);

        // TODO: To be implemented
    }

    function onClickDeleteVirtualDevice(event, virtualDeviceId) {
        console.log('onClickDeleteVirtualDevice:', ...arguments);

        // Only autorized if there are no more native capability
        // No need to check, the button is available only if authorized :)
        // No need to alert about the risk, the user has already been alerted when he removed the capability.ies
        Homey.showLoadingOverlay();

        let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
        if (virtualDevice.homeyId === null) {
            // It's a new device, we need to delete it for real
            let index = ongoingConfiguration.virtualDevices.indexOf(virtualDevice);
            console.log('Index to delete:', index);
            ongoingConfiguration.virtualDevices.splice(index, 1);
        } else {
            // It's a previously existing device, we just change its state to 'deleted'
            virtualDevice.state = 'deleted';
        }

        // Let's store it and refresh the view
        Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
            Homey.hideLoadingOverlay();
            Homey.showView('conf_main');
        });
    }

    function onClickDeleteNativeCapability(event, virtualDeviceId, nativeCapabilityId) {
        console.log('onClickDeleteNativeCapability:', ...arguments);

        // Delete a native capability from a virtual device! => unbind
        // Need to alert the user if he removes an existing native capability (ie. initial configuration)
        let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
        let virtualDeviceCapability = virtualDevice.capabilities.filter(capability => capability.nativeCapabilityId === nativeCapabilityId)[0];
        if (virtualDeviceCapability.state !== 'added') {
            Homey.confirm('Removing this capability can/will break your flows! Are you sure?', 'warning').then(() => {
                _delete_native_capability(virtualDevice, virtualDeviceCapability);
            });
        } else {
            _delete_native_capability(virtualDevice, virtualDeviceCapability);
        }
    }

    /**
     * Apply the ongoing configuration
     * 
     * /!\ Cannot go back ...
     */
    function onClickConfirm(event) {
        console.log('onClickConfirm:', ...arguments);

        // The confirm button has been clicked!

        // There are no errors, otherwise, the button cannot be clicked
        // But maybe there are warning!
        if (nbWarning > 0) {
            Homey.confirm(Homey.__('confirm_warning'), 'warning').then(() => {
                _confirm();
            });
        } else {
            _confirm();
        }
    }


    /**********************
     * Init view functions *
     **********************/

    function initView() {
        initPhysicalDevice();

        initVirtualDevices();

        initUnbindNativeCapabilities();

        console.log('View is initilized with', nbAlert, 'alert and', nbWarning, 'warning');
        nbAlert === 0 ? enableButton(document.getElementById('confirm')) : disableButton(document.getElementById('confirm'));

        // Finished init of the view
        Homey.hideLoadingOverlay();
    }

    function initPhysicalDevice() {
        //document.getElementById('physical_device.id').value = ongoing_configuration.physical_device.id;
        document.getElementById('physical_device.ipAddress').value = ongoingConfiguration.physicalDevice.ipAddress;
        document.getElementById('physical_device.port').value = ongoingConfiguration.physicalDevice.port;
    }

    function initVirtualDevices() {
        let listElement = document.getElementById('virtual_devices');

        // Any virtual device?
        if (ongoingConfiguration.virtualDevices.length === 0) {
            // Hide the table, we keep the warning
            document.getElementById('virtual_devices').remove();

            // This count as an alert
            _logAlert('No virtual device');
        } else {
            // Hide the warning
            document.getElementById('virtual_devices.none').remove();

            // Fill up the table
            ongoingConfiguration.virtualDevices.forEach(virtualDevice => {
                // Calculate the flags (used for special cases)
                // - noCapability: virtual device doesn't have any capability
                // - noActiveCapability: virtual device has capability, but they are all deleted and none has been added
                // - atLeastOneDeletedCapability : at least one 'existing' capability has been removed, it may breack the user flows!
                let noCapability = (virtualDevice.capabilities.length === 0);
                let noActiveCapability = (virtualDevice.capabilities.filter((capability) => capability.state !== 'deleted').length === 0);
                let atLeastOneDeletedCapability = (virtualDevice.capabilities.filter((capability) => capability.state === 'deleted').length >= 1);

                // Helper variables
                let row = null;
                let cellIndex = 0;

                // Cell variables (in order)
                let cellName = null;
                let cellState = null;
                let cellCapabilityType = null;
                let cellOptions = null;
                let cellNativeCapabilityName = null;
                let cellNativeCapabilityAttribut = null;
                let cellActions = null;


                // ***************
                // First, we add a virtual device row
                // ***************
                { // Just for indent
                    row = listElement.insertRow(-1);
                    cellIndex = 0;
                    cellName = row.insertCell(cellIndex++);
                    cellState = row.insertCell(cellIndex++);
                    cellCapabilityType = row.insertCell(cellIndex++);
                    cellCapabilityType.colSpan = 4; // We do not show any capability info on a virtual device line
                    cellActions = row.insertCell(cellIndex++);

                    if (virtualDevice.homeyId === null) {
                        // New virtual device, we allow modification of its name
                        cellName.innerHTML = '<input class="homey-form-input" type="text" value="' + virtualDevice.name + '" onchange="onChangeVirtualDeviceNameChanged(event, ' + "'" + virtualDevice.id + "'" + ', this.value);" style="margin-top:0px !important;"/>';
                    } else {
                        // Old virtual device, we do not allow modification of its name
                        cellName.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + virtualDevice.name + '</label>';
                    }
                    // State of the virtual device, in red if deleted!
                    cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;' + (virtualDevice.state === 'deleted' ? ' color:red;">' : '">') + Homey.__('wizard.conf_main.virtual_device.state.' + virtualDevice.state) + '</label>';

                    // Nothing in those columns
                    cellCapabilityType.innerHTML = '';

                    // Add the actions
                    cellActions.innerHTML = '';
                    if (virtualDevice.state === 'deleted') {
                        // Add restore action
                        cellActions.innerHTML += '<button class="homey-button-primary-full" onclick="onClickRestoreVirtualDevice(event, ' + "'" + virtualDevice.id + "'" + ');">' + Homey.__('wizard.conf_main.virtual_devices.actions.restore_virtual_device') + '</button>';
                    } else if (noActiveCapability) {
                        // Add delete action
                        cellActions.innerHTML += '<button class="homey-button-primary-full" onclick="onClickDeleteVirtualDevice(event, ' + "'" + virtualDevice.id + "'" + ');">' + Homey.__('wizard.conf_main.virtual_devices.actions.delete_virtual_device') + '</button>';
                    }

                    // Existing virtual device deleted ?
                    if (virtualDevice.state === 'deleted') {
                        // We add a warning message (in orange)
                        _logWarning('An existing virtual device is deleted');

                        row = listElement.insertRow(-1);
                        cellIndex = 0;
                        cellName = row.insertCell(cellIndex++);
                        cellState = row.insertCell(cellIndex++);
                        cellState.colSpan = 5; // warning row
                        cellActions = row.insertCell(cellIndex++);
                        cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;color:orange;">' + Homey.__('wizard.conf_main.virtual_devices.virtual_device_deleted_warning') + '</label>';
                    }

                    // Name must be changed?
                    if (virtualDevice.nameMustBeChanged) {
                        // We add an alert message (in red)
                        _logAlert('A virtual device name must be changed');

                        row = listElement.insertRow(-1);
                        cellIndex = 0;
                        cellName = row.insertCell(cellIndex++);
                        cellState = row.insertCell(cellIndex++);
                        cellState.colSpan = 5; // warning row
                        cellActions = row.insertCell(cellIndex++);
                        cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;color:red;">' + Homey.__('wizard.conf_main.virtual_devices.name_must_be_changed_alert') + '</label>';
                    }
                }


                // ***************
                // Second, we add capabilities rows
                // ***************
                { // Just for indent
                    // Any capability?
                    if (noCapability) {
                        // No capabilities, we add an alert message (in red)
                        _logAlert('A virtual device is missing a capability');

                        row = listElement.insertRow(-1);
                        cellIndex = 0;
                        cellName = row.insertCell(cellIndex++);
                        cellState = row.insertCell(cellIndex++);
                        cellState.colSpan = 5; // warning row
                        cellActions = row.insertCell(cellIndex++);
                        cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important; color:red;">' + Homey.__('wizard.conf_main.virtual_devices.no_native_capability_alert') + '</label>';
                    } else {
                        // Loop on all capabilities, and add them to the table
                        virtualDevice.capabilities.forEach(capability => {
                            // Get related native_capability
                            let nativeCapability = ongoingConfiguration.nativeCapabilities.filter((nativeCapability) => nativeCapability.id === capability.nativeCapabilityId)[0];

                            // We will use all the cells
                            row = listElement.insertRow(-1);
                            cellIndex = 0;
                            cellName = row.insertCell(cellIndex++);
                            cellState = row.insertCell(cellIndex++);
                            cellCapabilityType = row.insertCell(cellIndex++);
                            cellOptions = row.insertCell(cellIndex++);
                            cellNativeCapabilityName = row.insertCell(cellIndex++);
                            cellNativeCapabilityAttribut = row.insertCell(cellIndex++);
                            cellActions = row.insertCell(cellIndex++);

                            // It's a capability row, virtual device name stay empty
                            cellName.innerHTML = '';

                            // Show the state of the capability
                            // If the state is 'deleted', it means it is an existing native capability deleted => show it in orange
                            cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;' + (capability.state === 'deleted' ? ' color:orange;">' : '">') + capability.state + '</label>';

                            // Show the capability (homey)
                            // If the capability is 'deleted', we can just show the capability name
                            // Otherwise, it must be a select box
                            if (capability.state === 'deleted') {
                                cellCapabilityType.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + capability.type + '</label>';
                            } else {
                                let tmpSelect = '<select class="homey-form-select" onchange="onChangeAssignCapability(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', this.value" + ');">';
                                // Add a default if the capability is not yet choosen
                                if (capability.type === null) {
                                    // This count as an alert
                                    _logAlert("A virtual device's capability is missing a type");

                                    // TODO: actually, the option is not red ... need some css magic to do it seems
                                    tmpSelect += '<option value="default" selected style="color:red;">' + Homey.__('wizard.conf_main.virtual_devices.actions.no_capability_selected') + '</option>';
                                }

                                // Add compatible capabilities
                                // Ensure the current capability is selected by default
                                getCompatibleCapabilityTypes(nativeCapability).forEach(compatibleCapabilityType => {
                                    // TODO: We may want to translate the capability name ...
                                    tmpSelect += '<option value="' + compatibleCapabilityType + '" ' + (capability.type === compatibleCapabilityType ? 'selected' : '') + '>' + compatibleCapabilityType + '</option>';
                                });
                                tmpSelect += '</select>';
                                cellCapabilityType.innerHTML = tmpSelect;
                            }

                            // Show the capability options
                            // If the capability is 'deleted', we can just show the capability options
                            // Otherwise, they can be modified ...
                            if (capability.state === 'deleted') {
                                cellOptions.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;"><pre>' + JSON.stringify(capability.options, null, 2) + '</pre></label>';
                            } else {
                                // TODO: lot of things here ... in meantime, just show the options
                                //cellOptions.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;"><pre>' + JSON.stringify(capability.options, null, 2) + '</pre></label>';

                                let tmpOptions = '';

                                let options = capability.options;
                                Object.keys(options).forEach(key => {
                                    // Build a unique id
                                    let uniqueId = 'option_' + nativeCapability.id + '_' + key;
                                    switch (key) {
                                        case 'units':
                                            // Must be a text field, empty means unset
                                            tmpOptions += '<label class="homey-form-label" for="' + uniqueId + '" style="margin-top:0px !important;">' + key + '</label>'; // TODO: translation?
                                            tmpOptions += '<input class="homey-form-input" id="' + uniqueId + '" type="text" value="' + (options[key] ?? '') + '" onchange="onChangeCapabilityOption(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', '" + key + "'" + ', this.value);" style="margin-top:0px !important;"/>';
                                            break;

                                        case 'decimals':
                                            // Must be a select with values from 0 to 10 and unset value
                                            tmpOptions += '<label class="homey-form-label" for="' + uniqueId + '" style="margin-top:0px !important;">' + key + '</label>'; // TODO: translation?
                                            tmpOptions += '<select class="homey-form-select" id="' + uniqueId + '" onchange="onChangeCapabilityOption(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', '" + key + "'" + ', this.value);" style="margin-top:0px !important;">';
                                            tmpOptions += '<option value=""' + (options[key] === null ? ' selected' : '') + '>unset</option>';
                                            for (let i = 1; i <= 10; i++) {
                                                tmpOptions += '<option value="' + i + '" ' + (options[key] === i ? 'selected' : '') + '>' + i + '</option>';
                                            }
                                            tmpOptions += '</select>';
                                            break;

                                        case 'min':
                                        case 'max':
                                        case 'step':
                                            // Must be a text field (float), empty means unset
                                            tmpOptions += '<label class="homey-form-label" for="' + uniqueId + '" style="margin-top:0px !important;">' + key + '</label>'; // TODO: translation?
                                            tmpOptions += '<input class="homey-form-input" id="' + uniqueId + '" type="text" oninput="this.value = this.value.replace(/[^0-9.-]/g, ' + "''" + ').replace(/(\..*)\./g, ' + "'$1'" + ').replace(/(\-.*)\-/g, ' + "'$1'" + ');" value="' + (options[key] ?? '') + '" onchange="onChangeCapabilityOption(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', '" + key + "'" + ', this.value);" style="margin-top:0px !important;"/>';
                                            break;

                                        case 'zoneActivity':
                                        case 'approximated':
                                        case 'getable':
                                        case 'setable':
                                            // Must be a check box
                                            tmpOptions += '<label class="homey-form-checkbox" style="margin-top:0px !important;">';
                                            tmpOptions += '<input class="homey-form-checkbox-input" type="checkbox"' + (options[key] ? ' checked' : '') + ' onchange="onChangeCapabilityOption(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', '" + key + "'" + ', this.checked);" style="margin-top:0px !important;"/>';
                                            tmpOptions += '<span class="homey-form-checkbox-checkmark" style="margin-top:0px !important;"></span>';
                                            tmpOptions += '<span class="homey-form-checkbox-text" style="margin-top:0px !important;">' + key + '</span>'; // TODO: translation?
                                            tmpOptions += '</label>';
                                            break;
                                    }
                                });

                                cellOptions.innerHTML = tmpOptions;
                            }

                            // Show the native capability name
                            cellNativeCapabilityName.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.entityName + '</label>';

                            // Show the native capability attribut
                            cellNativeCapabilityAttribut.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.attribut + '</label>';

                            // Add the actions
                            cellActions.innerHTML = '';
                            if (capability.state !== 'deleted') {
                                // We can delete a capability
                                cellActions.innerHTML += '<button class="homey-button-primary-full" onclick="onClickDeleteNativeCapability(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "'" + ');">' + Homey.__('wizard.conf_main.virtual_devices.actions.delete_capability') + '</button>';
                            }
                        });

                        // Any existing capability deleted?
                        if (atLeastOneDeletedCapability) {
                            // We need to add a warning (in orange)
                            _logWarning('An existing virtual device has a capability deleted');

                            // The user must use the native_capability table to add them back! If he wants to do so ...
                            row = listElement.insertRow(-1);
                            cellIndex = 0;
                            cellName = row.insertCell(cellIndex++);
                            cellState = row.insertCell(cellIndex++);
                            cellState.colSpan = 5; // warning row
                            cellActions = row.insertCell(cellIndex++);
                            cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;color:orange;">' + Homey.__('wizard.conf_main.virtual_devices.native_capability_deleted_warning') + '</label>';
                        }
                    }
                }
            });

        }
    }

    function initUnbindNativeCapabilities() {
        let listElement = document.getElementById('unbind_native_capabilities');
        let count = 0;
        ongoingConfiguration.nativeCapabilities.forEach(nativeCapability => {
            if (nativeCapability.state === 'unbind') {
                ++count;

                let row = listElement.insertRow(-1);
                let cellIndex = 0; // Easier to add/remove cells if need in the future
                let cellEntityName = row.insertCell(cellIndex++);
                let cellType = row.insertCell(cellIndex++);
                let cellAttribut = row.insertCell(cellIndex++);
                let cellValue = row.insertCell(cellIndex++);
                let cellConfigs = row.insertCell(cellIndex++);
                let cellConstraints = row.insertCell(cellIndex++);
                let cellAction = row.insertCell(cellIndex++);

                cellEntityName.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.entityName + '</label>';
                cellType.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.type + '</label>';
                cellAttribut.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.attribut + '</label>';
                cellValue.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.value + '</label>';
                cellConfigs.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;"><pre>' + JSON.stringify(nativeCapability.configs, null, 2) + '</pre></label>';
                cellConstraints.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;"><pre>' + JSON.stringify(nativeCapability.constraints, null, 2) + '</pre></label>';

                let tmpAction = '';
                // Exclude deleted virtual devices!
                let filteredVirtualDevices = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.state !== 'deleted');
                if (filteredVirtualDevices.length > 0) {
                    tmpAction = '<select class="homey-form-select" onchange="onChangeAssignNativeCapability(event, this.value, ' + "'" + nativeCapability.id + "'" + ');">';
                    tmpAction += '<option value="default">' + Homey.__('wizard.conf_main.unbind_native_capabilities.action.no_virtual_device_selected') + '</option>';
                    filteredVirtualDevices.forEach(virtualDevice => {
                        tmpAction += '<option value="' + virtualDevice.id + '">' + virtualDevice.name + '</option>';
                    });
                    tmpAction += '</select>';
                } else {
                    // This message is in orange, but no need to count it (warning), an alert will be created because there are no virtual device
                    tmpAction = '<label class="homey-form-label" style="margin-top:0px !important; color:orange;">' + Homey.__('wizard.conf_main.unbind_native_capabilities.action.no_virtual_device') + '</label>';
                }
                cellAction.innerHTML = tmpAction;
            }
        });

        if (count === 0) {
            document.getElementById('unbind_native_capabilities.info').remove();
            document.getElementById('unbind_native_capabilities').remove();
        } else {
            document.getElementById('unbind_native_capabilities.none').remove();
        }
    }

    /**********************
     * Internal functions *
     **********************/

    /**
     * Emit event to Homey to retrieve the initial configuration from the Driver
     */
    function retrieveInitialConfiguration() {
        console.log('Retrieve initial configuration');

        Homey.getViewStore('store').then((store) => {
            console.log('Store:', store);

            let mode = store['mode'];
            let physicalDeviceId = store['physical_device_id'];

            console.log('Retrieved mode from store:', mode);
            console.log('Retrieved physical device id from store:', physicalDeviceId);

            Homey.emit("get-initial-configuration", { 'mode': mode, 'physicalDeviceId': physicalDeviceId }).then(function (result) {
                console.log('Initial configuration:', result);

                // We need a deep copy, so the ongoing configuration can evolve and we can compare to the initial configuration when needed
                ongoingConfiguration = JSON.parse(JSON.stringify(result));

                Homey.setViewStoreValue('store', 'initial configuration', result);
                Homey.setViewStoreValue('store', 'ongoing configuration', ongoingConfiguration);

                // Finished, init of the view
                initView();
            });

        });
    }

    function getCompatibleCapabilityTypes(nativeCapability) {
        // We use a multicriterea list to obtain the compatible capabilities
        // We just need to filter it

        // Prepare criterea
        let valueTypeCriterea = null; // One of boolean, number or string
        let getableCriterea = null; // boolean
        let setableCriterea = null; // boolean
        let nativeCapabilityCriterea = null // format: nativeCapability.type + '.' nativeCapability.attribut

        // Compute type
        switch (nativeCapability.type) {
            case 'BinarySensor':
            case 'Button':
            case 'Switch':
            valueTypeCriterea = 'boolean';
                break;

            case 'Cover':
            case 'Number':
            case 'Sensor':
            valueTypeCriterea = 'number';
                break;

            case 'TextSensor':
            valueTypeCriterea = 'string';
                break;
        }

        // Compute getable/setable
        if (nativeCapability.configs['readOnly']) {
            getableCriterea = true;
            setableCriterea = false;
        } else if (nativeCapability.configs['writeOnly']) {
            getableCriterea = false;
            setableCriterea = true;
        }

        // Compute native_capability
        nativeCapabilityCriterea = nativeCapability.type + '.' + nativeCapability.attribut;

        // Apply critera
        // A null criterea means don't apply it
        capabilityList = CAPABILITY_CONFIGURATION;
        if (valueTypeCriterea !== null) {
            capabilityList = capabilityList.filter(capabilityConf => capabilityConf.valueType === valueTypeCriterea);
        }
        if (getableCriterea !== null) {
            capabilityList = capabilityList.filter(capabilityConf => capabilityConf.getable === getableCriterea);
        }
        if (setableCriterea !== null) {
            capabilityList = capabilityList.filter(capabilityConf => capabilityConf.setable === setableCriterea);
        }
        capabilityList = capabilityList.filter(capabilityConf => capabilityConf.nativeCapabilitySupported === null || capabilityConf.nativeCapabilitySupported.includes(nativeCapabilityCriterea));
        capabilityList = capabilityList.filter(capabilityConf => capabilityConf.nativeCapabilityUnsupported === null || !capabilityConf.nativeCapabilityUnsupported.includes(nativeCapabilityCriterea));

        // Extract capabilities
        compatibleCapabilityTypes = [];
        capabilityList.forEach(capability => compatibleCapabilityTypes.push(capability.type));

        return compatibleCapabilityTypes;
    }

    function compareVirtualDeviceCapabilityOptions(leftOptions, rightOptions) {
        // We compare the keys from left to right
        // And then make sure if there are even more keys on right

        let result = true; // Same by default

        let countLeftOptions = 0;
        Object.keys(leftOptions).forEach((key) => {
            count_left_options++;
            if (leftOptions[key] !== rightOptions[key]) {
                result = false;
            }
        });

        if (result && Object.keys(rightOptions).length !== countLeftOptions) {
            result = false;
        }

        return result;
    }

    function _delete_native_capability(virtualDevice, virtualDeviceCapability) {
        // Even if its an existing capability, the user confirmed, peace to his soul ...
        Homey.showLoadingOverlay();

        if (virtualDeviceCapability.state === 'added') {
            // delete it
            let index = virtualDevice.capabilities.indexOf(virtualDeviceCapability);
            virtualDevice.capabilities.splice(index, 1);
        } else {
            // Change state to 'deleted'
            virtualDeviceCapability.state = 'deleted';
        }
        let nativeCapability = ongoingConfiguration.nativeCapabilities.filter(nativeCapability => nativeCapability.id === virtualDeviceCapability.nativeCapabilityId)[0];
        nativeCapability.state = 'unbind';

        // Let's store it and refresh the view
        Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
            Homey.hideLoadingOverlay();
            Homey.showView('conf_main');
        });
    }

    /**
     * For internal use only
     * Let's apply ...
     */
    async function _confirm() {
        console.log('How dare you ...');

        Homey.showLoadingOverlay();

        /**
         * We want to process in this order:
         * - Build all objects as expected by Homey
         * - Delete deleted virtual devices
         * - Modify modified virtual devices
         * - Create added virtual devices
         * 
         * This order will ensure that the native capabilities moved from one virtual device to another is succesfull!
         */


        // ***********
        // Step 1 - Build all the virtual devices object as expected by Homey
        // ***********
        let devicesToDelete = [];
        let devicesToUpdate = [];
        let devicesToCreate = [];

        ongoingConfiguration.virtualDevices.forEach(virtualDevice => {
            // If unmodified, there are nothing to modify :)
            if (virtualDevice.state === 'unmodified') {
                return;
            }

            // Blueprint of a Homey device
            var device = {
                name: null,
                class: "socket",
                capabilities: [],
                capabilitiesOptions: {},
                store: {
                    capabilityKeys: {} // pair of capability -> native_capability_id
                },
                data: {
                    id: null // Will generate it later
                },
                settings: { // Allows to reconnect to the physical device
                    ipAddress: null,
                    port: null,
                    password: null
                }
            };

            // Add name
            device.name = virtualDevice.name;

            // Add capabilities, their options and capabilityKeys
            let capabilityIndex = {};
            virtualDevice.capabilities.forEach(capability => {
                if (capability.state === 'deleted') {
                    return;
                }

                // Convert capability type to capability name
                // A capability name is for exemple: 'windowcoverings_set.2'
                // It happens when the same capability type is used several times for the same device!
                let capabilityName = capability.type;

                // If the same capability is used several times, we need to add index to the capability name
                if (capabilityIndex.capabilityName) {
                    capabilityIndex[capabilityName] += 1;
                    capabilityName = capabilityName + capabilityIndex[capabilityName];
                } else {
                    capabilityIndex[capabilityName] = 0;
                }

                device.capabilities.push(capabilityName);
                device.capabilitiesOptions[capabilityName] = capability.options;
                device.store.capabilityKeys[capabilityName] = capability.nativeCapabilityId;
            });

            // Add data => unique identifier!
            if (virtualDevice.state === 'added') {
                // We will generate it later
            } else {
                device.data = {
                    id: virtualDevice.homeyId
                };
            }

            // Add settings
            // FIXME: We just bring password around and not crypted ... how nice
            device.settings['ipAddress'] = ongoingConfiguration.physicalDevice.ipAddress;
            device.settings['port'] = ongoingConfiguration.physicalDevice.port;
            device.settings['password'] = ongoingConfiguration.physicalDevice.password;

            // Which list
            switch (virtualDevice.state) {
                case 'deleted':
                    devicesToDelete.push(device);
                    break;

                case 'modified':
                    devicesToUpdate.push(device);
                    break;

                case 'added':
                    devicesToCreate.push(device);
                    break;
            }
        });

        // ***********
        // Step 2 - Delete
        // ***********
        // TODO: to be implemented
        console.log('Devices to delete:', devicesToDelete);

        // ***********
        // Step 3 - Update
        // ***********
        // TODO: to be implemented
        console.log('Devices to update:', devicesToUpdate);

        // ***********
        // Step 4 - Create
        // ***********
        // TODO: to be implemented
        console.log('Devices to create:', devicesToCreate);

        let deviceIndex = 1;
        await devicesToCreate.forEach(async deviceToCreate => {
            // Let's make some test
            deviceToCreate.data.id = 'Wizard' + Date.now() + deviceIndex++;

            await Homey.createDevice(deviceToCreate);
        });

        Homey.hideLoadingOverlay();
        Homey.done();
    }

    function _logAlert(message) {
        console.log('Alert:', message);
        ++nbAlert;
    }

    function _logWarning(message) {
        console.log('Warning:', message);
        ++nbWarning;
    }

    /*************
     * MAIN CODE *
     *************/

    initial_configuration = null;
    ongoingConfiguration = null;

    /**
     * Some flags to handle confirm button
     */
    nbAlert = 0; // Increase everytime we show a red message (alert => blocking)
    nbWarning = 0; // Increase everytime we show an orange message (warning => not blocking)

    // Check if initial configuration is already in the store view
    // If not, emit get-initial-configuration and store the initial configuration in the store view (also stored as ongoing configuration)
    // We can then init the view based on ongoing configuration from the store
    Homey.getViewStoreValue('store', 'ongoing_configuration').then(function (result) {
        console.log('Ongoing configuration from store:', result);

        if (!result) {
            retrieveInitialConfiguration();
        } else {
            ongoingConfiguration = result;

            // Finished, init of the view
            initView();
        }
    });
</script>