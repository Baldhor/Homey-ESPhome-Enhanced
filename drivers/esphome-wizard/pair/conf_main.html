<!--
    Show a summary of ongoing configuration:
    - Virtual device, its capabilities and related native capabilities => only offer a "goto" button (go to view 'conf_virtual_device')
    - Settings, and its related native capabilities => only offer a "goto" button (go to view 'conf_settings')
    - Unbind native capabilities => only offer a "create a new virtual device" button (then go to view 'conf_virtual_device')

    Initialy, the ongoing configuration is based on current Homey configuration, and the current physical device configuration.
    After each modifications, the ongoing configuration will update.

    This view also has a "confirm" button which will apply definitively all the modifications.
-->
<style>
    table {
        font-family: arial, sans-serif;
        border-collapse: collapse;
        width: 100%;
    }

    td,
    th {
        border: 1px solid #dddddd;
        text-align: left;
        padding: 8px;
    }

    tr:nth-child(even) {
        background-color: #dddddd;
    }
</style>

<script src="front_configuration.js"></script>
<script src="front_utils.js"></script>
<script type="application/javascript">
    Homey.setTitle(Homey.__('wizard.conf_main.title'));
    Homey.setNavigationClose();

    Homey.showLoadingOverlay();
</script>
<label class="homey-form-label" data-i18n="wizard.conf_main.description"></label>

<!--
    physical_device
-->
<br>
<br>
<header class="homey-header">
    <p class="homey-subtitle" data-i18n="wizard.conf_main.physical_device.title">
        <!-- This field will also be translated -->
    </p>
</header>
<div class="homey-form-group">
    <!-- Seems useless, it is built from: <ipAddress> + ':' + <port>
    <div class="homey-form-group">
        <label class="homey-form-label" for="physical_device.id" data-i18n="wizard.conf_main.physical_device.id"></label>
        <input class="homey-form-input" id="physical_device.id" type="text" value="" readonly/>
    </div>
    -->
    <div class="homey-form-group">
        <label class="homey-form-label" for="physical_device.ipAddress"
            data-i18n="wizard.conf_main.physical_device.ipAddress"></label>
        <input class="homey-form-input" id="physical_device.ipAddress" type="text" value="" readonly />
    </div>
    <div class="homey-form-group">
        <label class="homey-form-label" for="physical_device.port"
            data-i18n="wizard.conf_main.physical_device.port"></label>
        <input class="homey-form-input" id="physical_device.port" type="text" value="" readonly />
    </div>
</div>

<!--
    Virtual device list

    Structure expected:
    - Header line
    - Virtual device 'first line', include first native capability
    - Virtual device 'more lines', for other native capability (doesn't repeat the name of the virtual device)
-->
<br>
<br>
<header class="homey-header">
    <p class="homey-subtitle" data-i18n="wizard.conf_main.virtual_devices.title">
        <!-- This field will also be translated -->
    </p>
</header>
<div class="homey-form-group">
    <label id="virtual_devices.none" class="homey-form-label" data-i18n="wizard.conf_main.virtual_devices.none"
        style="color:red;"></label>
    <table id="virtual_devices" style="width:400% !important;">
        <tr>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.virtual_device.name"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.virtual_device.stateLabel"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.homey_capability.name"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.homey_capability.options"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.name"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.attribut"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.virtual_devices.actions.title"></legend>
            </th>
        </tr>
    </table>
    <button id="create_virtual_device" class="homey-button-primary-full"
        data-i18n="wizard.conf_main.virtual_devices.create" onclick="onClickCreateVirtualDevice(event);"></button>
</div>

<!--
    Unbind native capabilities
-->
<br>
<br>
<header class="homey-header">
    <p class="homey-subtitle" data-i18n="wizard.conf_main.unbind_native_capabilities.title">
        <!-- This field will also be translated -->
    </p>
</header>
<div class="homey-form-group">
    <label id="unbind_native_capabilities.info" class="homey-form-label"
        data-i18n="wizard.conf_main.unbind_native_capabilities.info"></label>
    <label id="unbind_native_capabilities.none" class="homey-form-label"
        data-i18n="wizard.conf_main.unbind_native_capabilities.none"></label>
    <table id="unbind_native_capabilities" style="width:400% !important;">
        <tr>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.name"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.type"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.attribut"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.value"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.configs"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.native_capability.constraints"></legend>
            </th>
            <th>
                <legend class="homey-form-legend" data-i18n="wizard.conf_main.unbind_native_capabilities.action.label">
                </legend>
            </th>
        </tr>
    </table>
</div>
<br>

<!--
    Confirm button
-->
<button id="confirm" class="homey-button-primary-full" data-i18n="wizard.conf_main.confirm"
    onclick="onClickConfirm(event);"></button>


<script type="application/javascript">
    /***************
     * HTML Events *
     ***************/

    function onChangeCapabilityOption(event, virtualDeviceId, nativeCapabilityId, optionId, newValue) {
        console.log('onChangeCapabilityOption:', ...arguments);

        let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
        let capability = virtualDevice.capabilities.filter(capability => capability.nativeCapabilityId === nativeCapabilityId)[0];

        // Value changed ?
        newValue = newValue === '' ? null : newValue;

        // Need to convert new value to the right type?
        console.log('New option value:', newValue, 'of type', typeof newValue);
        switch (optionId) {
            case 'title':
            case 'units':
                break;

            case 'decimals':
                newValue = newValue === null ? null : parseInt(newValue);
                break;

            case 'min':
            case 'max':
            case 'step':
                newValue = newValue === null ? null : parseFloat(newValue);
                break;

            case 'preventInsights':
            case 'preventTag':
            case 'zoneActivity':
            case 'approximated':
            case 'getable':
            case 'setable':
                break;

            default:
                return;
        }

        if (capability.options[optionId] !== newValue) {
            Homey.showLoadingOverlay();

            capability.options[optionId] = newValue;

            // We need to change the state of the capability
            // Different cases:
            // - added: we don't care
            // - modified: If the user set back its old value, then we may need to set the state to unmodified
            // - unmodified: jsut make it modified

            if (capability.state === 'unmodified' || capability.state === 'updated') {
                capability.state = 'modified';
            } else if (capability.state === 'modified') {
                let initialVirtualDevice = initialConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
                let initialCapability = initialVirtualDevice.capabilities.filter(capability => capability.nativeCapabilityId === nativeCapabilityId)[0];

                if (compareVirtualDeviceCapabilityOptions(capability.options, initialCapability.options)) {
                    // The same options, meaning the state is unmodified
                    capability.state = 'unmodified';
                }
            }

            // Let's store it and refresh the view
            Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                Homey.hideLoadingOverlay();
                Homey.showView('conf_main');
            });
        }
    }

    function onChangeAssignCapability(event, virtualDeviceId, nativeCapabilityId, newValue) {
        console.log('onChangeAssignCapability:', ...arguments);

        // Ignore default choice
        if (newValue !== 'default') {
            Homey.showLoadingOverlay();

            // Get our objects from ongoing configuration
            let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
            let nativeCapability = ongoingConfiguration.nativeCapabilities.filter(nativeCapability => nativeCapability.id === nativeCapabilityId)[0];

            // Let's find the capability of the virtual device
            let capability = virtualDevice.capabilities.filter(capability => capability.nativeCapabilityId === nativeCapabilityId)[0];

            // The value changed?
            if (capability.type !== newValue) {
                // We need to consider several cases based on the state of the capability
                // - added : just apply new capability and initialize its options
                // - unmodified : set the capability as modified, nullify its name and initialize its options
                // - modified :
                //     - The user set its old capability? We need to reset its name and options to their initial values
                //     - If not: initialize its options

                capability.type = newValue;
                switch (capability.state) {
                    case 'unmodified':
                    case 'updated':
                        capability.name = null;
                        capability.state = 'modified';
                        capability.options = _getCapabilityOptionsFromNativeCapability(capability.type, nativeCapability);
                        break;

                    case 'added':
                        capability.options = _getCapabilityOptionsFromNativeCapability(capability.type, nativeCapability);
                        break;

                    case 'modified':
                        let initialVirtualDevice = initialConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
                        let initialCapability = initialVirtualDevice.capabilities.filter(capability => capability.nativeCapabilityId === nativeCapabilityId)[0];

                        if (initialCapability.type === capability.type) {
                            // The user set its old capability
                            capability.state = 'unmodified';
                            capability.name = initialCapability.name;
                            capability.options = JSON.parse(JSON.stringify(initialCapability).options); // Making sure to make a copy :)

                            // However, the configuration of a capability may have changed
                            _updateCapabilityForNewConfiguration(capability);
                        } else {
                            capability.options = _getCapabilityOptionsFromNativeCapability(capability.type, nativeCapability);
                        }
                        break;
                }

                // Let's store it and refresh the view
                Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                    Homey.hideLoadingOverlay();
                    Homey.showView('conf_main');
                });
            } else {
                // Nothing to do
                Homey.hideLoadingOverlay();
            }
        }
    }

    function onChangeAssignNativeCapability(event, virtualDeviceId, nativeCapabilityId) {
        console.log('onChangeAssignNativeCapability:', ...arguments);

        // TODO: Add the ability to assign a capability to a 'new' virtual device (ie. create it!):
        //    - The name of the virtual device could be set to the native capability name
        //    - If only one capability compatible for the native capability, we could also set it directly, meaning init the options too

        if (virtualDeviceId !== 'default') {
            Homey.showLoadingOverlay();

            // Get the virtual device and native capability
            let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
            let nativeCapability = ongoingConfiguration.nativeCapabilities.filter(nativeCapability => nativeCapability.id === nativeCapabilityId)[0];

            // If the virtual device is 'added', then the native capability is just 'added' too
            // If the native capability was previously removed from the same virtual device, we just need to restore it
            // But could be in 'unmodified' or 'modified' state, need to check the initial configuration to make sure
            // Otherwise, it means the native capability is 'added'
            let state = 'added'; // Cover first and last cases
            if (virtualDevice.state !== 'added') {
                let filterVirtualDeviceCapabilities = virtualDevice.capabilities.filter((capability) => capability.nativeCapabilityId === nativeCapabilityId);
                if (filterVirtualDeviceCapabilities.length === 1) {
                    // Found it, it is either 'unmodified' or 'modifie
                    // No need to check if it was previously 'deleted' (let's trust the code ...)
                    virtualDeviceCapability = filterVirtualDeviceCapabilities[0];

                    let initialVirtualDeviceCapability = initialConfiguration.virtualDevices.filter((virtualDevice) => virtualDevice.id === virtualDeviceId)[0].capabilities.filter((capability) => capability.nativeCapabilityId === nativeCapabilityId)[0];
                    if (compareVirtualDeviceCapabilityOptions(initialVirtualDeviceCapability.options, virtualDeviceCapability.options)) {
                        // Same
                        state = 'unmodified';
                    } else {
                        state = 'modified';
                    }

                    // Actually, we just need to restore it with the correct state
                    virtualDeviceCapability.state = state;
                    nativeCapability.state = 'bound';

                    // Let's store it and refresh the view
                    Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                        Homey.hideLoadingOverlay();
                        Homey.showView('conf_main');
                    });
                    return;
                }
            }

            let capabilityType = null;

            // TODO: If only one capability compatible for the native capability, we could set it directly, meaning init the options too

            // It's a new capability for the virtual device
            let capability = {
                type: capabilityType,
                'nativeCapabilityId': nativeCapabilityId,
                'state': state,
                options: []
            };
            virtualDevice.capabilities.push(capability);
            nativeCapability.state = 'bound';

            // Let's store it and refresh the view
            Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                Homey.hideLoadingOverlay();
                Homey.showView('conf_main');
            });
        }
    }

    /**
     * This function add a virtual device
     * 
     * By default:
     * - Its name is generated : new1, new2, ...
     * - it doesn't have any native capability, the user need to add at least one
     * 
     * /!\ Name must be changed and at least one native capaibility must be added, otherwise the confirm button is disabled
     */
    function onClickCreateVirtualDevice(event) {
        console.log('onClickCreateVirtualDevice:', ...arguments);

        Homey.showLoadingOverlay();

        // Get nextValue from the store
        Homey.getViewStoreValue('store', 'last_virtual_device_id').then(lastId => {
            if (!lastId) {
                lastId = 0;
            }

            let nextId = lastId + 1;
            Homey.setViewStoreValue('store', 'last_virtual_device_id', nextId).then(() => {
                // finaly, we got an id, let's create a virtual device
                let newVirtualDevice = {
                    id: 'new_' + nextId,
                    homeyId: null,
                    name: 'new_' + nextId,
                    nameMustBeChanged: true,
                    state: 'added',
                    capabilities: []
                };

                // We can add it to the ongoing_configuration
                ongoingConfiguration.virtualDevices.push(newVirtualDevice);

                // Let's store it and refresh the view
                Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                    Homey.hideLoadingOverlay();
                    Homey.showView('conf_main');
                });
            });
        });
    }

    function onChangeVirtualDeviceNameChanged(event, virtualDeviceId, newName) {
        console.log('onChangeVirtualDeviceNameChanged:', ...arguments);

        // Let's check the newName format
        if (/^[A-Za-z0-9][A-Za-z0-9-_ ]{1,28}[A-Za-z0-9]{1,1}$/.test(newName)) {
            Homey.showLoadingOverlay();
            ongoingConfiguration.virtualDevices.forEach(virtualDevice => {
                if (virtualDevice.id === virtualDeviceId) {
                    virtualDevice.name = newName;
                    virtualDevice.nameMustBeChanged = false;
                }
            });

            // Let's store it and refresh the view
            Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
                Homey.hideLoadingOverlay();
                Homey.showView('conf_main');
            });
        } else {
            // Not nice, alert and reload
            // TODO: There are must be better way to handle it, but it is simple :)
            Homey.alert(Homey.__('wizard.conf_main.virtual_devices.change_name_format'));
            Homey.showView('conf_main');
        }
    }

    function onClickDeleteVirtualDevice(event, virtualDeviceId) {
        console.log('onClickDeleteVirtualDevice:', ...arguments);

        // Only autorized for new virtual devices and if there are no more native capability
        // No need to check, the button is available only if authorized :)
        Homey.showLoadingOverlay();

        let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
        // It's a new device, we need to delete it for real
        let index = ongoingConfiguration.virtualDevices.indexOf(virtualDevice);
        console.log('Index to delete:', index);
        ongoingConfiguration.virtualDevices.splice(index, 1);

        // Let's store it and refresh the view
        Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
            Homey.hideLoadingOverlay();
            Homey.showView('conf_main');
        });
    }

    function onClickDeleteNativeCapability(event, virtualDeviceId, nativeCapabilityId) {
        console.log('onClickDeleteNativeCapability:', ...arguments);

        // Delete a native capability from a virtual device! => unbind
        // Need to alert the user if he removes an existing native capability (ie. initial configuration)
        let virtualDevice = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.id === virtualDeviceId)[0];
        let virtualDeviceCapability = virtualDevice.capabilities.filter(capability => capability.nativeCapabilityId === nativeCapabilityId)[0];
        if (virtualDeviceCapability.state !== 'added') {
            Homey.confirm(Homey.__('wizard.conf_main.virtual_devices.delete_existing_native_capability_warning'), 'warning').then(() => {
                _delete_native_capability(virtualDevice, virtualDeviceCapability);
            });
        } else {
            _delete_native_capability(virtualDevice, virtualDeviceCapability);
        }
    }

    /**
     * Apply the ongoing configuration
     * 
     * /!\ Cannot go back ...
     */
    function onClickConfirm(event) {
        console.log('onClickConfirm:', ...arguments);

        // The confirm button has been clicked!

        // There are no errors, otherwise, the button cannot be clicked
        // But maybe there are warning!
        if (nbWarning > 0) {
            Homey.confirm(Homey.__('wizard.conf_main.confirm_warning'), 'warning').then(() => {
                _confirm();
            });
        } else {
            _confirm();
        }
    }


    /**********************
     * Init view functions *
     **********************/

    function initView() {
        initPhysicalDevice();

        initVirtualDevices();

        initUnbindNativeCapabilities();

        console.log('View is initilized with', nbAlert, 'alert and', nbWarning, 'warning');
        nbAlert === 0 ? enableButton(document.getElementById('confirm')) : disableButton(document.getElementById('confirm'));

        // Finished init of the view
        Homey.hideLoadingOverlay();
    }

    function initPhysicalDevice() {
        //document.getElementById('physical_device.id').value = ongoing_configuration.physical_device.id;
        document.getElementById('physical_device.ipAddress').value = ongoingConfiguration.physicalDevice.ipAddress;
        document.getElementById('physical_device.port').value = ongoingConfiguration.physicalDevice.port;
    }

    function initVirtualDevices() {
        let listElement = document.getElementById('virtual_devices');

        // Any virtual device?
        if (ongoingConfiguration.virtualDevices.length === 0) {
            // Hide the table, we keep the warning
            document.getElementById('virtual_devices').remove();

            // This count as an alert
            _logAlert('No virtual device');
        } else {
            // Hide the warning
            document.getElementById('virtual_devices.none').remove();

            // Fill up the table
            ongoingConfiguration.virtualDevices.forEach(virtualDevice => {
                // Calculate the flags (used for special cases)
                // - noCapability: virtual device doesn't have any capability
                // - noActiveCapability: virtual device has capability, but they are all deleted and none has been added
                // - atLeastOneDeletedCapability : at least one 'existing' capability has been removed, it may breack the user flows!
                // - atLeastOneUpdatedCapability : at least one capability has been updated to new configuration
                let noCapability = (virtualDevice.capabilities.length === 0);
                let noActiveCapability = (virtualDevice.capabilities.filter((capability) => capability.state !== 'deleted').length === 0);
                let atLeastOneDeletedCapability = (virtualDevice.capabilities.filter((capability) => capability.state === 'deleted').length >= 1);
                let atLeastOneUpdatedCapability = (virtualDevice.capabilities.filter((capability) => capability.state === 'updated').length >= 1);

                // Helper variables
                let row = null;
                let cellIndex = 0;

                // Cell variables (in order)
                let cellName = null;
                let cellState = null;
                let cellCapabilityType = null;
                let cellOptions = null;
                let cellNativeCapabilityName = null;
                let cellNativeCapabilityAttribut = null;
                let cellActions = null;


                // ***************
                // First, we add a virtual device row
                // ***************
                { // Just for indent
                    row = listElement.insertRow(-1);
                    cellIndex = 0;
                    cellName = row.insertCell(cellIndex++);
                    cellState = row.insertCell(cellIndex++);
                    cellCapabilityType = row.insertCell(cellIndex++);
                    cellCapabilityType.colSpan = 4; // We do not show any capability info on a virtual device line
                    cellActions = row.insertCell(cellIndex++);

                    if (virtualDevice.homeyId === null) {
                        // New virtual device, we allow modification of its name
                        cellName.innerHTML = '<input class="homey-form-input" type="text" value="' + virtualDevice.name + '" onchange="onChangeVirtualDeviceNameChanged(event, ' + "'" + virtualDevice.id + "'" + ', this.value);" style="margin-top:0px !important;"/>';
                    } else {
                        // Old virtual device, we do not allow modification of its name
                        cellName.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + virtualDevice.name + '</label>';
                    }
                    // State of the virtual device, in red if deleted!
                    cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;' + (virtualDevice.state === 'deleted' ? ' color:red;">' : '">') + Homey.__('wizard.conf_main.virtual_device.state.' + virtualDevice.state) + '</label>';

                    // Nothing in those columns
                    cellCapabilityType.innerHTML = '';

                    // Add the actions
                    cellActions.innerHTML = '';
                    if (noCapability) {
                        // Only new virtual devices can have 'no capabilties'
                        // Add delete action
                        cellActions.innerHTML += '<button class="homey-button-primary-full" onclick="onClickDeleteVirtualDevice(event, ' + "'" + virtualDevice.id + "'" + ');">' + Homey.__('wizard.conf_main.virtual_devices.actions.delete_virtual_device') + '</button>';
                    }

                    // Name must be changed?
                    if (virtualDevice.nameMustBeChanged) {
                        // We add an alert message (in red)
                        _logAlert('A new virtual device name must be changed');

                        row = listElement.insertRow(-1);
                        cellIndex = 0;
                        cellName = row.insertCell(cellIndex++);
                        cellState = row.insertCell(cellIndex++);
                        cellState.colSpan = 5; // warning row
                        cellActions = row.insertCell(cellIndex++);
                        cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;color:red;">' + Homey.__('wizard.conf_main.virtual_devices.name_must_be_changed_alert') + '</label>';
                    }
                }


                // ***************
                // Second, we add capabilities rows
                // ***************
                { // Just for indent
                    // Any capability?
                    if (noCapability) {
                        // No capabilities, we add an alert message (in red)
                        _logAlert('A virtual device is missing a capability');

                        row = listElement.insertRow(-1);
                        cellIndex = 0;
                        cellName = row.insertCell(cellIndex++);
                        cellState = row.insertCell(cellIndex++);
                        cellState.colSpan = 5; // warning row
                        cellActions = row.insertCell(cellIndex++);
                        cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important; color:red;">' + Homey.__('wizard.conf_main.virtual_devices.no_native_capability_alert') + '</label>';
                    } else {
                        // Loop on all capabilities, and add them to the table
                        virtualDevice.capabilities.forEach(capability => {
                            // Get related native_capability
                            let nativeCapability = ongoingConfiguration.nativeCapabilities.filter((nativeCapability) => nativeCapability.id === capability.nativeCapabilityId)[0];

                            // We will use all the cells
                            row = listElement.insertRow(-1);
                            cellIndex = 0;
                            cellName = row.insertCell(cellIndex++);
                            cellState = row.insertCell(cellIndex++);
                            cellCapabilityType = row.insertCell(cellIndex++);
                            cellOptions = row.insertCell(cellIndex++);
                            cellNativeCapabilityName = row.insertCell(cellIndex++);
                            cellNativeCapabilityAttribut = row.insertCell(cellIndex++);
                            cellActions = row.insertCell(cellIndex++);

                            // It's a capability row, virtual device name stay empty
                            cellName.innerHTML = '';

                            // Show the state of the capability
                            // If the state is 'deleted', it means it is an existing native capability deleted => show it in orange
                            cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;' + (capability.state === 'deleted' ? ' color:orange;">' : '">') + Homey.__('wizard.conf_main.native_capability.state.' + capability.state) + '</label>';

                            // Show the capability (homey)
                            // If the capability is 'deleted', we can just show the capability name
                            // Otherwise, it must be a select box
                            if (capability.state === 'deleted') {
                                cellCapabilityType.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + capability.type + '</label>';
                            } else {
                                let tmpSelect = '<select class="homey-form-select" onchange="onChangeAssignCapability(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', this.value" + ');">';
                                // Add a default if the capability is not yet choosen
                                if (capability.type === null) {
                                    // This count as an alert
                                    _logAlert("A virtual device's capability is missing a type");

                                    // TODO: actually, the option is not red ... need some css magic to do it seems
                                    tmpSelect += '<option value="default" selected style="color:red;">' + Homey.__('wizard.conf_main.virtual_devices.actions.no_capability_selected') + '</option>';
                                }

                                // Add compatible capabilities
                                // Ensure the current capability is selected by default
                                getCompatibleCapabilityTypes(nativeCapability).forEach(compatibleCapabilityType => {
                                    // TODO: We may want to translate the capability name ...
                                    tmpSelect += '<option value="' + compatibleCapabilityType + '" ' + (capability.type === compatibleCapabilityType ? 'selected' : '') + '>' + compatibleCapabilityType + '</option>';
                                });
                                tmpSelect += '</select>';
                                cellCapabilityType.innerHTML = tmpSelect;
                            }

                            // Show the capability options
                            // If the capability is 'deleted', we can just show the capability options
                            // Otherwise, they can be modified ...
                            if (capability.state === 'deleted') {
                                cellOptions.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;"><pre>' + JSON.stringify(capability.options, null, 2) + '</pre></label>';
                            } else {
                                // TODO: lot of things here ... in meantime, just show the options
                                //cellOptions.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;"><pre>' + JSON.stringify(capability.options, null, 2) + '</pre></label>';

                                let tmpOptions = '';

                                let options = capability.options;
                                Object.keys(options).forEach(key => {
                                    // Build a unique id
                                    let uniqueId = 'option_' + nativeCapability.id + '_' + key;
                                    // TODO: Add oninput constraints?
                                    switch (key) {
                                        case 'title':
                                        case 'units':
                                            // Must be a text field, empty means unset
                                            tmpOptions += '<label class="homey-form-label" for="' + uniqueId + '" style="margin-top:0px !important;">' + key + '</label>'; // TODO: translation?
                                            tmpOptions += '<input class="homey-form-input" id="' + uniqueId + '" type="text" value="' + (options[key] ?? '') + '" onchange="onChangeCapabilityOption(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', '" + key + "'" + ', this.value);" style="margin-top:0px !important;"/>';
                                            break;

                                        case 'decimals':
                                            // Must be a select with values from 0 to 10 and unset value
                                            tmpOptions += '<label class="homey-form-label" for="' + uniqueId + '" style="margin-top:0px !important;">' + key + '</label>'; // TODO: translation?
                                            tmpOptions += '<select class="homey-form-select" id="' + uniqueId + '" onchange="onChangeCapabilityOption(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', '" + key + "'" + ', this.value);" style="margin-top:0px !important;">';
                                            tmpOptions += '<option value=""' + (options[key] === null ? ' selected' : '') + '>unset</option>';
                                            for (let i = 1; i <= 10; i++) {
                                                tmpOptions += '<option value="' + i + '" ' + (options[key] === i ? 'selected' : '') + '>' + i + '</option>';
                                            }
                                            tmpOptions += '</select>';
                                            break;

                                        case 'min':
                                        case 'max':
                                        case 'step':
                                            // Must be a text field (float), empty means unset
                                            tmpOptions += '<label class="homey-form-label" for="' + uniqueId + '" style="margin-top:0px !important;">' + key + '</label>'; // TODO: translation?
                                            tmpOptions += '<input class="homey-form-input" id="' + uniqueId + '" type="text" oninput="this.value = this.value.replace(/[^0-9.-]/g, ' + "''" + ').replace(/(\..*)\./g, ' + "'$1'" + ').replace(/(\-.*)\-/g, ' + "'$1'" + ');" value="' + (options[key] ?? '') + '" onchange="onChangeCapabilityOption(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', '" + key + "'" + ', this.value);" style="margin-top:0px !important;"/>';
                                            break;

                                        case 'preventInsights':
                                        case 'preventTag':
                                        case 'zoneActivity':
                                        case 'approximated':
                                        case 'getable':
                                        case 'setable':
                                            // Must be a check box
                                            tmpOptions += '<label class="homey-form-checkbox" style="margin-top:0px !important;">';
                                            tmpOptions += '<input class="homey-form-checkbox-input" type="checkbox"' + (options[key] ? ' checked' : '') + ' onchange="onChangeCapabilityOption(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "', '" + key + "'" + ', this.checked);" style="margin-top:0px !important;"/>';
                                            tmpOptions += '<span class="homey-form-checkbox-checkmark" style="margin-top:0px !important;"></span>';
                                            tmpOptions += '<span class="homey-form-checkbox-text" style="margin-top:0px !important;">' + key + '</span>'; // TODO: translation?
                                            tmpOptions += '</label>';
                                            break;
                                    }
                                });

                                cellOptions.innerHTML = tmpOptions;
                            }

                            // Show the native capability name
                            cellNativeCapabilityName.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.entityName + '</label>';

                            // Show the native capability attribut
                            cellNativeCapabilityAttribut.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.attribut + '</label>';

                            // Add the actions
                            cellActions.innerHTML = '';
                            if (capability.state !== 'deleted') {
                                // We can delete a capability
                                cellActions.innerHTML += '<button class="homey-button-primary-full" onclick="onClickDeleteNativeCapability(event, ' + "'" + virtualDevice.id + "', '" + nativeCapability.id + "'" + ');">' + Homey.__('wizard.conf_main.virtual_devices.actions.delete_capability') + '</button>';
                            }
                        });

                        // Any existing capability deleted?
                        if (atLeastOneDeletedCapability) {
                            // We need to add a warning (in orange)
                            _logWarning('An existing virtual device has a capability deleted');

                            // The user must use the native_capability table to add them back! If he wants to do so ...
                            row = listElement.insertRow(-1);
                            cellIndex = 0;
                            cellName = row.insertCell(cellIndex++);
                            cellState = row.insertCell(cellIndex++);
                            cellState.colSpan = 5; // warning row
                            cellActions = row.insertCell(cellIndex++);
                            cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;color:orange;">' + Homey.__('wizard.conf_main.virtual_devices.native_capability_deleted_warning') + '</label>';
                        }

                        // Any existing capability updated?
                        if (atLeastOneUpdatedCapability) {
                            // We need to add a warning (in orange)
                            _logWarning('At least one updated capability');

                            // The user must use the native_capability table to add them back! If he wants to do so ...
                            row = listElement.insertRow(-1);
                            cellIndex = 0;
                            cellName = row.insertCell(cellIndex++);
                            cellState = row.insertCell(cellIndex++);
                            cellState.colSpan = 5; // warning row
                            cellActions = row.insertCell(cellIndex++);
                            cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;color:orange;">' + Homey.__('wizard.conf_main.virtual_devices.capability_updated_warning') + '</label>';
                        }

                        // There are no active capability
                        if (noActiveCapability) {
                            // We need to add an alert (in red)
                            _logAlert('No active capability');

                            // The user must use the native_capability table to add them back! If he wants to do so ...
                            row = listElement.insertRow(-1);
                            cellIndex = 0;
                            cellName = row.insertCell(cellIndex++);
                            cellState = row.insertCell(cellIndex++);
                            cellState.colSpan = 5; // warning row
                            cellActions = row.insertCell(cellIndex++);
                            cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;color:red;">' + Homey.__('wizard.conf_main.virtual_devices.no_native_capability_alert') + '</label>';

                            if (virtualDevice.state === 'existing') {
                                // We need to add a warning (in orange)
                                _logWarning('Use virtual device setting screen to delete');

                                // The user must use the native_capability table to add them back! If he wants to do so ...
                                row = listElement.insertRow(-1);
                                cellIndex = 0;
                                cellName = row.insertCell(cellIndex++);
                                cellState = row.insertCell(cellIndex++);
                                cellState.colSpan = 5; // warning row
                                cellActions = row.insertCell(cellIndex++);
                                cellState.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;color:orange;">' + Homey.__('wizard.conf_main.virtual_devices.delete_through_settings') + '</label>';
                            }
                        }
                    }
                }
            });

        }
    }

    function initUnbindNativeCapabilities() {
        let listElement = document.getElementById('unbind_native_capabilities');
        let count = 0;
        ongoingConfiguration.nativeCapabilities.forEach(nativeCapability => {
            if (nativeCapability.state === 'unbind') {
                ++count;

                let row = listElement.insertRow(-1);
                let cellIndex = 0; // Easier to add/remove cells if need in the future
                let cellEntityName = row.insertCell(cellIndex++);
                let cellType = row.insertCell(cellIndex++);
                let cellAttribut = row.insertCell(cellIndex++);
                let cellValue = row.insertCell(cellIndex++);
                let cellConfigs = row.insertCell(cellIndex++);
                let cellConstraints = row.insertCell(cellIndex++);
                let cellAction = row.insertCell(cellIndex++);

                cellEntityName.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.entityName + '</label>';
                cellType.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.type + '</label>';
                cellAttribut.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.attribut + '</label>';
                cellValue.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;">' + nativeCapability.value + '</label>';
                cellConfigs.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;"><pre>' + JSON.stringify(nativeCapability.configs, null, 2) + '</pre></label>';
                cellConstraints.innerHTML = '<label class="homey-form-label" style="margin-top:0px !important;"><pre>' + JSON.stringify(nativeCapability.constraints, null, 2) + '</pre></label>';

                let tmpAction = '';
                // Exclude deleted virtual devices!
                let filteredVirtualDevices = ongoingConfiguration.virtualDevices.filter(virtualDevice => virtualDevice.state !== 'deleted');
                if (filteredVirtualDevices.length > 0) {
                    tmpAction = '<select class="homey-form-select" onchange="onChangeAssignNativeCapability(event, this.value, ' + "'" + nativeCapability.id + "'" + ');">';
                    tmpAction += '<option value="default">' + Homey.__('wizard.conf_main.unbind_native_capabilities.action.no_virtual_device_selected') + '</option>';
                    filteredVirtualDevices.forEach(virtualDevice => {
                        tmpAction += '<option value="' + virtualDevice.id + '">' + virtualDevice.name + '</option>';
                    });
                    tmpAction += '</select>';
                } else {
                    // This message is in orange, but no need to count it (warning), an alert will be created because there are no virtual device
                    tmpAction = '<label class="homey-form-label" style="margin-top:0px !important; color:orange;">' + Homey.__('wizard.conf_main.unbind_native_capabilities.action.no_virtual_device') + '</label>';
                }
                cellAction.innerHTML = tmpAction;
            }
        });

        if (count === 0) {
            document.getElementById('unbind_native_capabilities.info').remove();
            document.getElementById('unbind_native_capabilities').remove();
        } else {
            document.getElementById('unbind_native_capabilities.none').remove();
        }
    }

    /**********************
     * Internal functions *
     **********************/

    /**
     * Emit event to Homey to retrieve the initial configuration from the Driver
     */
    function retrieveInitialConfiguration() {
        console.log('Retrieve initial configuration');

        Homey.getViewStore('store').then((store) => {
            console.log('Store:', store);

            let mode = store['mode'];
            let physicalDeviceId = store['physical_device_id'];

            console.log('Retrieved mode from store:', mode);
            console.log('Retrieved physical device id from store:', physicalDeviceId);

            Homey.emit("get-initial-configuration", { 'mode': mode, 'physicalDeviceId': physicalDeviceId }).then(function (result) {
                console.log('Initial configuration:', result);

                // We need a deep copy, so the ongoing configuration can evolve and we can compare to the initial configuration when needed
                initialConfiguration = result;
                ongoingConfiguration = JSON.parse(JSON.stringify(result));

                // We need to check if the existing devices' capabilities are 'up to date'
                ongoingConfiguration.virtualDevices.forEach(virtualDevice => {
                    virtualDevice.capabilities.forEach(capability => {
                        _updateCapabilityForNewConfiguration(capability);
                    })
                });

                Homey.setViewStoreValue('store', 'initial_configuration', result);
                Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration);

                // Finished, init of the view
                initView();
            });

        });
    }

    /**
     * This function is used to:
     * - 'update' the options of an existing capability
     *   For the simple reason that the configuration may have changed: options removed or added
     *   We exclude the case where an option type changed :)
     * - 'delete' a capability if its native capability doesn't exist anymore or became not compatible
     * 
     * /!\ This function should be called only when the capability is 'unmodified'
     * 
     * A capability 'updated' by this function gain the state 'updated'.
     * If the user modify it afterward, it will become 'modified'.
     */
    function _updateCapabilityForNewConfiguration(capability) {
        console.log('_updateCapabilityForNewConfiguration:', ...arguments);

        if (capability.state !== 'unmodified') {
            console.log('Why call me for a', capability.state, 'capability');
            return;
        }

        // Let's find the native capability
        let nativeCapabilities = ongoingConfiguration.nativeCapabilities.filter(nativeCapability => nativeCapability.id === capability.nativeCapabilityId);
        if (nativeCapabilities.length === 0) {
            // This native capability doesn't exist anymore ...
            // How sad
            capability.state = 'deleted';
            capability.nativeCapabilityId = null;
            capability.options = null;

            return;
        } else if (!getCompatibleCapabilityTypes(nativeCapabilities[0]).includes(capability.type)) {
            // This native capability is not compatible anymore ...
            // The user need to choose a new capability
            // How sad
            capability.state = 'modified';
            capability.type = null;
            capability.name = null;
            capability.options = null;

            return;

        }

        // We use the default options for the native capability
        let defaultOptions = _getCapabilityOptionsFromNativeCapability(capability.type, nativeCapabilities[0]);

        // Compare defaultOptions with existing options
        Object.keys(defaultOptions).forEach(optionKey => {
            if (capability.options[optionKey] === undefined) {
                // Option is missing, we need to add it
                capability.options[optionKey] = defaultOptions[optionKey];
                capability.state = 'updated';
            }
        });

        // Let's compare in the other direction
        Object.keys(capability.options).forEach(optionKey => {
            if (defaultOptions[optionKey] === undefined) {
                // Option is not supported anymore, we need to remove it
                delete capability.options[optionKey];
                capability.state = 'updated';
            }
        });
    }

    function _getCapabilityOptionsFromNativeCapability(capabilityType, nativeCapability) {
        console.log('_getCapabilityOptionsFromNativeCapability:', ...arguments);

        // Get the capability configuration
        let capabilityConf = CAPABILITY_CONFIGURATION.filter(compatibleCapability => compatibleCapability.type === capabilityType)[0];

        // We need to initialize the options
        let options = {};
        capabilityConf.options.forEach(option => options[option] = null);

        // Let's check if we can init some values from the native_capability itself
        Object.keys(options).forEach(key => {
            switch (key) {
                case 'units':
                    options[key] = nativeCapability.configs['unit'] ?? null;
                    break;

                case 'decimals':
                    options[key] = nativeCapability.configs['precision'] ?? null;
                    break;

                case 'min':
                    options[key] = nativeCapability.constraints['min'] ?? null;
                    break;

                case 'max':
                    options[key] = nativeCapability.constraints['max'] ?? null;
                    break;

                case 'step':
                    options[key] = nativeCapability.constraints['step'] ?? null;
                    break;

                case 'zoneActivity':
                    // no match, default to true
                    options[key] = true;
                    break;

                case 'approximated':
                    // no match, default to false
                    options[key] = false;
                    break;

                case 'getable':
                    options[key] = nativeCapability.configs['writeOnly'] ?? null;
                    break;

                case 'setable':
                    options[key] = nativeCapability.configs['readOnly'] ?? null;
                    break;
            }
        });

        return options;
    }

    function getCompatibleCapabilityTypes(nativeCapability) {
        console.log('getCompatibleCapabilityTypes:', ...arguments);

        // We use a multicriterea list to obtain the compatible capabilities
        // We just need to filter it

        // Prepare criterea
        let valueTypeCriterea = null; // One of boolean, number or string
        let getableCriterea = null; // boolean
        let setableCriterea = null; // boolean
        let nativeCapabilityCriterea = null // format: nativeCapability.type + '.' nativeCapability.attribut

        // Compute type
        switch (nativeCapability.type) {
            case 'BinarySensor':
            case 'Button':
            case 'Switch':
                valueTypeCriterea = 'boolean';
                break;

            case 'Cover':
            case 'Number':
            case 'Sensor':
                valueTypeCriterea = 'number';
                break;

            case 'TextSensor':
                valueTypeCriterea = 'string';
                break;
        }

        // Compute getable/setable
        if (nativeCapability.configs['readOnly']) {
            getableCriterea = true;
            setableCriterea = false;
        } else if (nativeCapability.configs['writeOnly']) {
            getableCriterea = false;
            setableCriterea = true;
        }

        // Compute native_capability
        nativeCapabilityCriterea = nativeCapability.type + '.' + nativeCapability.attribut;

        // Apply critera
        // A null criterea means don't apply it
        capabilityList = CAPABILITY_CONFIGURATION;
        if (valueTypeCriterea !== null) {
            capabilityList = capabilityList.filter(capabilityConf => capabilityConf.valueType === valueTypeCriterea);
        }
        if (getableCriterea !== null) {
            capabilityList = capabilityList.filter(capabilityConf => capabilityConf.getable === getableCriterea);
        }
        if (setableCriterea !== null) {
            capabilityList = capabilityList.filter(capabilityConf => capabilityConf.setable === setableCriterea);
        }
        capabilityList = capabilityList.filter(capabilityConf => capabilityConf.nativeCapabilitySupported === null || capabilityConf.nativeCapabilitySupported.includes(nativeCapabilityCriterea));
        capabilityList = capabilityList.filter(capabilityConf => capabilityConf.nativeCapabilityUnsupported === null || !capabilityConf.nativeCapabilityUnsupported.includes(nativeCapabilityCriterea));

        // Extract capabilities
        compatibleCapabilityTypes = [];
        capabilityList.forEach(capability => compatibleCapabilityTypes.push(capability.type));

        return compatibleCapabilityTypes;
    }

    function compareVirtualDeviceCapabilityOptions(leftOptions, rightOptions) {
        console.log('compareVirtualDeviceCapabilityOptions:', ...arguments);

        // We compare the keys from left to right
        // And then make sure if there are even more keys on right

        let result = true; // Same by default

        let countLeftOptions = 0;
        Object.keys(leftOptions).forEach((key) => {
            countLeftOptions++;
            if (leftOptions[key] !== rightOptions[key]) {
                result = false;
            }
        });

        if (result && Object.keys(rightOptions).length !== countLeftOptions) {
            result = false;
        }

        return result;
    }

    function _delete_native_capability(virtualDevice, virtualDeviceCapability) {
        console.log('_delete_native_capability:', ...arguments);

        // Even if its an existing capability, the user confirmed, peace to his soul ...
        Homey.showLoadingOverlay();

        if (virtualDeviceCapability.state === 'added') {
            // delete it
            let index = virtualDevice.capabilities.indexOf(virtualDeviceCapability);
            virtualDevice.capabilities.splice(index, 1);
        } else {
            // Change state to 'deleted'
            virtualDeviceCapability.state = 'deleted';
        }
        let nativeCapability = ongoingConfiguration.nativeCapabilities.filter(nativeCapability => nativeCapability.id === virtualDeviceCapability.nativeCapabilityId)[0];
        nativeCapability.state = 'unbind';

        // Let's store it and refresh the view
        Homey.setViewStoreValue('store', 'ongoing_configuration', ongoingConfiguration).then(() => {
            Homey.hideLoadingOverlay();
            Homey.showView('conf_main');
        });
    }

    /**
     * For internal use only
     * Let's apply ...
     */
    async function _confirm() {
        console.log('_confirm');

        Homey.showLoadingOverlay();

        /**
         * We want to process in this order:
         * - Build all objects as expected
         * - Remove existing virtual devices capabilities
         * - Add existing virtual devices capabilities
         * - Modify existing virtual devices capabilities
         * - Create added virtual devices with their capabilities
         * 
         * This order will ensure that the native capabilities moved from one virtual device to another is succesfull!
         * 
         * /!\ An existing virtual device capability modified can be:
         * - A change of the capability type => mean a 'remove' + an 'add'
         * - A change of its options => mean a 'modify'
         */


        // ***********
        // Step 1 - Build all the virtual devices object as expected by Homey
        //
        // capabilitiesToRemove: [
        //     {
        //         deviceId : string,
        //         capabilities : [string]
        //     }
        // ]
        //
        // capabilitiesToAdd: [
        //     {
        //         deviceId: string,
        //         capabilities: [
        //             {
        //                 capabilityName : string,
        //                 nativeCapabilityId : string,
        //                 options : {
        //                     <key: string>: <value: any>
        //                 }
        //             }
        //         ]
        //     {
        // ]
        //
        // capabilitiesToModify: [
        //     {
        //         deviceId: string,
        //         capabilities: [
        //             {
        //                 capabilityName : string,
        //                 options : {
        //                     <key: string>: <value: any>
        //                 }
        //             }
        //         ]
        //     {
        // ]
        //
        // deviceToCreate: [
        //     {
        //         name: string,
        //         class: "socket", // TODO: handle more class?
        //         capabilities: [string],
        //         capabilitiesOptions: {
        //             <key: string>: <value: any>
        //         },
        //         store: {
        //             capabilityKeys: {
        //                 <capabilityName: string>: <native_capability_id: string>
        //         },
        //         data: {
        //             id: string
        //         },
        //         settings: { // Allows to reconnect to the physical device
        //             ipAddress: string,
        //             port: string,
        //             password: string
        //         }
        //     }
        // ]
        // ***********

        let capabilitiesToRemove = [];
        let capabilitiesToModify = [];
        let capabilitiesToAdd = [];
        let devicesToCreate = [];

        console.log('Computing actions to apply');
        ongoingConfiguration.virtualDevices.forEach(virtualDevice => {
            if (virtualDevice.state === 'existing') {
                // ****************
                // Existing virtual device
                // ****************
                console.log('Processing existing virtual device', virtualDevice.id);

                // Build a list of the existing capabilityNames to avoid duplicate
                let capabilityNames = [];
                virtualDevice.capabilities.forEach(capability => {
                    if (capability.name) {
                        capabilityNames.push(capability.name);
                    }
                });
                console.log('Built existing capabilityNames', capabilityNames);

                // Loop on all capabilities and process each case separatly
                virtualDevice.capabilities.forEach(capability => {
                    switch (capability.state) {
                        case 'unmodified':
                            console.log('Capability unmodified:', capability);

                            // Do nothing
                            break;

                        case 'added':
                            console.log('Capability to add:', capability);
                            _addAddAction(virtualDevice, capability, capabilityNames, capabilitiesToAdd);

                            console.log('Capability processed:', capability);
                            break;

                        case 'modified':
                        case 'updated':
                            console.log('Capability to modify:', capability);

                            // Is the capability type modified ? If so its name is null ..
                            if (capability.name !== null) {
                                // It's a simple modification of the options
                                console.log('Capability options to modify:', capability);
                                _addModifyAction(virtualDevice, capability, capabilitiesToModify);
                            } else {
                                // It's a change of capability type, we need to delete and add ...

                                // We search the initial capabilioty by nativeCapabilityId (name is null, and type may not be unique!)
                                let initialCapability = initialConfiguration.virtualDevices.filter(initialVirtualDevice => initialVirtualDevice.id === virtualDevice.id)[0].capabilities.filter(initialCapability => initialCapability.nativeCapabilityId === capability.nativeCapabilityId)[0];
                                console.log('Capability type to modify:', capability);
                                _addDeleteAction(virtualDevice, initialCapability, capabilitiesToRemove);
                                _addAddAction(virtualDevice, capability, capabilityNames, capabilitiesToAdd);
                            }

                            console.log('Capability processed:', capability);
                            break;

                        case 'deleted':
                            console.log('Capability to delete:', capability);
                            _addDeleteAction(virtualDevice, capability, capabilitiesToRemove);

                            console.log('Capability processed:', capability);
                            break;

                        default:
                            console.log('Device', virtualDevice.id, 'has a capability with an unexpected state:', capability);
                            Homey.hideLoadingOverlay();
                            return;
                    }
                });

            } else if (virtualDevice.state === 'added') {
                // ****************
                // New virtual device
                // ****************
                console.log('Processing new virtual device', virtualDevice.id);
                _addCreateAction(virtualDevice, devicesToCreate);

                console.log('New virtual device processed:', virtualDevice);
            } else {
                console.log('Unexpected state for device:', virtualDevice);
                Homey.hideLoadingOverlay();
                return;
            }
        });

        // ***********
        // Step 2 - Delete capabilities
        // ***********
        if (capabilitiesToRemove.length) {
            console.log('Capabilities to remove:', capabilitiesToRemove);
            await Homey.emit("remove-capabilities", {
                'devices': capabilitiesToRemove
            });
        }

        // ***********
        // Step 3 - Update capabilities
        // ***********
        if (capabilitiesToModify.length) {
            console.log('Capabilities to modify:', capabilitiesToModify);
            await Homey.emit("modify-capabilities", {
                'devices': capabilitiesToModify
            });
        }

        // ***********
        // Step 4 - Add capabilities
        // ***********
        if (capabilitiesToAdd.length) {
            console.log('Capabilities to add:', capabilitiesToAdd);
            await Homey.emit("add-capabilities", {
                'devices': capabilitiesToAdd
            });
        }

        // ***********
        // Step 5 - Create virtual devices
        // ***********
        if (devicesToCreate.length) {
            console.log('Devices to create:', devicesToCreate);

            let deviceIndex = 1;
            await devicesToCreate.forEach(async deviceToCreate => {
                deviceToCreate.data.id = 'Wizard' + Date.now() + deviceIndex++;
                console.log('Creating device:', deviceToCreate);

                await Homey.createDevice(deviceToCreate);
            });
        }

        console.log('Finished processing all actions');

        Homey.hideLoadingOverlay();
        Homey.done();
    }

    function _addAddAction(virtualDevice, capability, capabilityNames, capabilitiesToAdd) {
        console.log('_addAddAction:', ...arguments);

        // Compute a capabilityName
        // Index 0: '<capabilityType>'
        // Index >0: '<capabilityType>.<index>'
        let capabilityName = capability.type;
        let index = 0;
        while (capabilityNames.includes(capabilityName)) {
            index++;
            capabilityName = capability.type + '.' + index;
        }

        // Add the capabilityName to the list
        capabilityNames.push(capabilityName);

        // Build the capability object
        let capabilityToAdd = {
            'capabilityName': capabilityName,
            'nativeCapabilityId': capability.nativeCapabilityId,
            'options': capability.options
        };

        // Check if the device is already added to capabilitiesToAdd
        let capabilityToAddObject = capabilitiesToAdd.find(capabilityToAdd => capabilityToAdd.deviceId === virtualDevice.id);
        if (!capabilityToAddObject) {
            capabilityToAddObject = {
                'deviceId': virtualDevice.id,
                'capabilities': []
            }
            capabilitiesToAdd.push(capabilityToAddObject);
        }
        capabilityToAddObject.capabilities.push(capabilityToAdd);
    }

    function _addModifyAction(virtualDevice, capability, capabilitiesToModify) {
        console.log('_addModifyAction:', ...arguments);

        // Build the capability object
        let capabilityToModify = {
            'capabilityName': capability.name,
            'options': capability.options
        };

        // Check if the device is already added to capabilitiesToAdd
        let capabilityToModifyObject = capabilitiesToModify.find(capabilityToModify => capabilityToModify.deviceId === virtualDevice.id);
        if (!capabilityToModifyObject) {
            capabilityToModifyObject = {
                'deviceId': virtualDevice.id,
                'capabilities': []
            }
            capabilitiesToModify.push(capabilityToModifyObject);
        }
        capabilityToModifyObject.capabilities.push(capabilityToModify);
    }

    function _addDeleteAction(virtualDevice, capability, capabilitiesToRemove) {
        console.log('_addDeleteAction:', ...arguments);

        // Check if the device is already added to capabilitiesToAdd
        let capabilityToRemoveObject = capabilitiesToRemove.find(capabilityToRemove => capabilityToRemove.deviceId === virtualDevice.id);
        if (!capabilityToRemoveObject) {
            capabilityToRemoveObject = {
                'deviceId': virtualDevice.id,
                'capabilities': []
            }
            capabilitiesToRemove.push(capabilityToRemoveObject);
        }
        capabilityToRemoveObject.capabilities.push(capability.name);
    }

    function _addCreateAction(virtualDevice, devicesToCreate) {
        console.log('_addCreateAction:', ...arguments);

        // Blueprint of a Homey device
        var device = {
            name: null,
            class: "socket",
            capabilities: [],
            capabilitiesOptions: {},
            store: {
                capabilityKeys: {} // pair of capability -> native_capability_id
            },
            data: {
                id: null // Will generate it later
            },
            settings: { // Allows to reconnect to the physical device
                ipAddress: null,
                port: null,
                password: null
            }
        };

        // Add name
        device.name = virtualDevice.name;

        // Add capabilities, their options and capabilityKeys
        let capabilityIndex = {};
        virtualDevice.capabilities.forEach(capability => {
            if (capability.state === 'deleted') {
                return;
            }

            // Convert capability type to capability name
            // A capability name is for exemple: 'windowcoverings_set.2'
            // It happens when the same capability type is used several times for the same device!
            let capabilityName = capability.type;

            // If the same capability is used several times, we need to add index to the capability name
            if (capabilityIndex.capabilityName) {
                capabilityIndex[capabilityName] += 1;
                capabilityName = capabilityName + capabilityIndex[capabilityName];
            } else {
                capabilityIndex[capabilityName] = 0;
            }

            device.capabilities.push(capabilityName);
            device.capabilitiesOptions[capabilityName] = capability.options;
            device.store.capabilityKeys[capabilityName] = capability.nativeCapabilityId;
        });

        // Add settings
        // FIXME: We just bring password around and not crypted ... how nice
        device.settings['ipAddress'] = ongoingConfiguration.physicalDevice.ipAddress;
        device.settings['port'] = ongoingConfiguration.physicalDevice.port;
        device.settings['password'] = ongoingConfiguration.physicalDevice.password;

        devicesToCreate.push(device);
    }

    function _logAlert(message) {
        console.log('Alert:', message);
        ++nbAlert;
    }

    function _logWarning(message) {
        console.log('Warning:', message);
        ++nbWarning;
    }

    /*************
     * MAIN CODE *
     *************/

    initialConfiguration = null;
    ongoingConfiguration = null;

    /**
     * Some flags to handle confirm button
     */
    nbAlert = 0; // Increase everytime we show a red message (alert => blocking)
    nbWarning = 0; // Increase everytime we show an orange message (warning => not blocking)

    // Check if initial configuration is already in the store view
    // If not, emit get-initial-configuration and store the initial configuration in the store view (also stored as ongoing configuration)
    // We can then init the view based on ongoing configuration from the store
    Homey.getViewStoreValue('store', 'initial_configuration').then(function (result) {
        console.log('Initial configuration from store:', result);

        if (!result) {
            retrieveInitialConfiguration();
        } else {
            initialConfiguration = result;

            Homey.getViewStoreValue('store', 'ongoing_configuration').then(function (result) {
                console.log('Ongoing configuration from store:', result);

                ongoingConfiguration = result;

                // Finished, init of the view
                initView();
            });
        }
    });
</script>